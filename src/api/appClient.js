const STORAGE_KEY = 'verdent_vision_db_v2';
const SESSION_KEY = 'verdent_vision_session';

const nowIso = () => new Date().toISOString();
const makeId = () => globalThis.crypto?.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(16).slice(2)}`;

const seedDatabase = () => ({
  User: [
    {
      id: 'u-admin',
      full_name: 'Charles Admin',
      email: 'charlesabhishekreddy@gmail.com',
      role: 'admin',
      provider: 'google',
      farm_location: 'Main Farm',
      created_date: nowIso(),
    },
  ],
  PlantDatabase: [
    { id: 'p1', common_name: 'Tomato', scientific_name: 'Solanum lycopersicum', common_diseases: ['Early Blight', 'Late Blight'], common_pests: ['Aphids'], created_date: nowIso() },
    { id: 'p2', common_name: 'Potato', scientific_name: 'Solanum tuberosum', common_diseases: ['Scab'], common_pests: ['Beetle'], created_date: nowIso() },
  ],
  PlantDiagnosis: [], Treatment: [], Task: [], PestPrediction: [], WeatherLog: [], OutbreakReport: [], DiagnosisFeedback: [], ForumPost: [], CropPlan: [],
});

const readDb = () => {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) {
    const db = seedDatabase();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(db));
    return db;
  }
  try { return JSON.parse(raw); } catch { return seedDatabase(); }
};
const writeDb = (db) => localStorage.setItem(STORAGE_KEY, JSON.stringify(db));

const sortItems = (items, sortBy = '') => {
  if (!sortBy) return [...items];
  const desc = sortBy.startsWith('-');
  const field = desc ? sortBy.slice(1) : sortBy;
  return [...items].sort((a, b) => {
    const av = a?.[field]; const bv = b?.[field];
    if (av == null && bv == null) return 0;
    if (av == null) return 1;
    if (bv == null) return -1;
    return desc ? String(bv).localeCompare(String(av)) : String(av).localeCompare(String(bv));
  });
};

const entityApi = (entityName) => ({
  async list(sortBy = '', limit) {
    const items = sortItems(readDb()[entityName] || [], sortBy);
    return Number.isFinite(limit) ? items.slice(0, limit) : items;
  },
  async filter(criteria = {}, sortBy = '', limit) {
    const filtered = (readDb()[entityName] || []).filter((item) => Object.entries(criteria).every(([k, v]) => item?.[k] === v));
    const items = sortItems(filtered, sortBy);
    return Number.isFinite(limit) ? items.slice(0, limit) : items;
  },
  async create(data) {
    const db = readDb();
    const item = { id: makeId(), created_date: nowIso(), ...data };
    db[entityName] = [...(db[entityName] || []), item];
    writeDb(db);
    return item;
  },
  async update(id, data) {
    const db = readDb();
    let updated;
    db[entityName] = (db[entityName] || []).map((i) => {
      if (String(i.id) !== String(id)) return i;
      updated = { ...i, ...data, updated_date: nowIso() };
      return updated;
    });
    writeDb(db);
    return updated;
  },
  async delete(id) {
    const db = readDb();
    const before = (db[entityName] || []).length;
    db[entityName] = (db[entityName] || []).filter((i) => String(i.id) !== String(id));
    writeDb(db);
    return { success: before > db[entityName].length };
  },
});

const getSession = () => {
  try { return JSON.parse(localStorage.getItem(SESSION_KEY) || 'null'); } catch { return null; }
};
const setSession = (user) => localStorage.setItem(SESSION_KEY, JSON.stringify(user));
const clearSession = () => localStorage.removeItem(SESSION_KEY);

const upsertUserByEmail = (profile) => {
  const db = readDb();
  const adminAllowList = (import.meta.env.VITE_ADMIN_EMAILS || 'charlesabhishekreddy@gmail.com').split(',').map((x) => x.trim().toLowerCase());
  const role = adminAllowList.includes(profile.email.toLowerCase()) ? 'admin' : 'member';
  const found = (db.User || []).find((u) => u.email?.toLowerCase() === profile.email.toLowerCase());
  const user = found ? { ...found, ...profile, role, updated_date: nowIso() } : { id: makeId(), created_date: nowIso(), role, ...profile };
  db.User = [user, ...(db.User || []).filter((u) => u.email?.toLowerCase() !== profile.email.toLowerCase())];
  writeDb(db);
  return user;
};

const createMockFromSchema = (schema) => {
  if (!schema) return { text: 'Local AI mock output' };
  if (schema.enum?.length) return schema.enum[0];
  if (schema.type === 'boolean') return true;
  if (schema.type === 'number' || schema.type === 'integer') return 82;
  if (schema.type === 'array') return [createMockFromSchema(schema.items || { type: 'string' })];
  if (schema.type === 'object') {
    const o = {};
    Object.entries(schema.properties || {}).forEach(([k, v]) => (o[k] = createMockFromSchema(v)));
    return o;
  }
  return 'Generated by Verdent AI';
};

const entities = new Proxy({}, { get: (_t, prop) => entityApi(prop) });

export const appClient = {
  entities,
  auth: {
    async me() {
      const session = getSession();
      if (session) return session;
      throw Object.assign(new Error('Authentication required'), { status: 401 });
    },
    async signInWithGoogle(profile) {
      const user = upsertUserByEmail({
        full_name: profile.name,
        email: profile.email,
        avatar_url: profile.picture,
        provider: 'google',
      });
      setSession(user);
      return user;
    },
    async updateMe(updateData) {
      const current = await this.me();
      const user = upsertUserByEmail({ ...current, ...updateData });
      setSession(user);
      return user;
    },
    logout(redirectTo) {
      clearSession();
      if (redirectTo) window.location.href = redirectTo;
    },
    redirectToLogin(redirectTo) {
      const next = encodeURIComponent(redirectTo || window.location.href);
      window.location.href = `/login?next=${next}`;
    },
  },
  users: {
    async inviteUser(email, role = 'member') {
      return upsertUserByEmail({ email, full_name: email.split('@')[0], role, invited: true });
    },
  },
  integrations: {
    Core: {
      async UploadFile({ file }) {
        if (file instanceof File) return { file_url: URL.createObjectURL(file) };
        return { file_url: '' };
      },
      async InvokeLLM({ response_json_schema }) {
        return createMockFromSchema(response_json_schema);
      },
    },
  },
  appLogs: {
    async logUserInApp(pageName) {
      const db = readDb();
      db.ActivityLog = db.ActivityLog || [];
      db.ActivityLog.push({ id: makeId(), pageName, created_date: nowIso() });
      writeDb(db);
      return { success: true };
    },
  },
};
